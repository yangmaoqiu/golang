name: Build for LoongArch64

on:
  push:
    branches: [main, master]
  pull_request:
    branches: [main, master]
  workflow_dispatch:

jobs:
  build:
    runs-on: ubuntu-latest
    container:
      # 使用专门为交叉编译优化的镜像
      image: ghcr.io/loongarch64/clfs-os-cross:latest
    env:
      GOPROXY: https://goproxy.cn,direct
      
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up Go
      uses: actions/setup-go@v5
      with:
        go-version: '1.22'

    - name: Build
      run: |
        echo "在容器环境内开始编译..."
        
        # 1. 初始化模块并强制升级 purego
        if [ ! -f "go.mod" ]; then
          go mod init github.com/yangmaoqiu/golang
        fi
        
        # 升级 purego 以修复 v0.7.0 的结构体定义 Bug
        go get github.com/ebitengine/purego@latest
        go mod tidy
        
        # 2. 设置交叉编译环境变量
        # 该镜像内编译器通常已经配置好，或者是标准的 loongarch64-unknown-linux-gnu-gcc
        export CGO_ENABLED=1
        export GOOS=linux
        export GOARCH=loong64
        
        # 自动查找容器内的交叉编译器
        if command -v loongarch64-unknown-linux-gnu-gcc &> /dev/null; then
          export CC=loongarch64-unknown-linux-gnu-gcc
        elif command -v loongarch64-linux-gnu-gcc &> /dev/null; then
          export CC=loongarch64-linux-gnu-gcc
        fi
        
        echo "使用编译器: $CC"

        # 3. 编译
        # 暂时去掉 -static，先确保能编译过，再考虑静态链接
        go build -ldflags="-w -s" -o main-loong64 .
        
        echo "✅ 编译完成"
        
    - name: Verify
      run: |
        if [ -f "main-loong64" ]; then
          # 容器内可能没装 file 命令，如果报错可以忽略此步
          ls -lh main-loong64
        else
          echo "❌ 错误: 未生成 main-loong64"
          exit 1
        fi
        
    - name: Upload Artifact
      uses: actions/upload-artifact@v4
      with:
        name: loong64-binary
        path: main-loong64
